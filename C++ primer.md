#  C++ primer

## Ⅰ：C++基础

### 1、变量和基本类型

#### 1.1基本内置类型

##### 	1.1.1算术类型

​	c++包含一些算术类型（arithmetic type）和空类型（void）在内的数据类型，包含**字符，整形数，布尔值和浮点数**，**带符号类型和无符号类型**

##### 	1.1.2类型转换

​	需要避免无法预知和依赖于实现环境的行为

​	避免无法控制，没有依据的强制转换行为

​	需要避免带符号和无符号混合使用

##### 	1.1.3字面值常量

​	整形和浮点型字面值

​	字符和字符串字面值

​	转义序列

#### 1.2变量

##### 	1.2.1变量定义

​	类型说明符（int、long long、double……）

​	初始值（初始化和赋值时两个单独的过程，不能混为一谈）

​	列表初始化（C++11新特性，int x(0) 或者 int x{0} 或者int x = {0}，0可以为变量或者常量）

> ​     当用于内置类型的变量时，这种初始化形式（花括号）有一个重要特性：如果我们使用初始化且初始值存在丢失信息的风险，则会报错

​	默认初始化（堆空间默认初始化、栈空间不被初始化）

##### 	1.2.2变量声明和定义的关系

声明使名字为程序所知，定义创建与名字关联的实体

为了支持分离式编译，C++将其区分开来，变量只能被定义一次，但是可以被多次声明，如果在多个文件中使用同一个变量，就必须分开，此时，变量的定义必须在且只能出现在一个文件中，而其他用到改变量的文件必须对其进行声明，却绝对不能重复定义。

```c++
extern int  i // 声明i为非定义i
int j // 声明并定义j
extern double pi = 3.14159 //定义
```

##### 	1.2.3标识符

下划线，字母，数字。数字不能开头。

命名规范：

- 标识符要能体现实际意义

- 变量名一般小写

- 用户自定义类名一般大写字母开头

- 如果标识符由多个单词组成，单词间区分应该由明显区分，如 student_loan 或 studentLoan,不要使用studentloan

  > 对于命名规范来说，若能坚持，必将有效

##### 	1.2.4名字的作用域

全局，函数，for， if 里面的花括号内部

分为**全局作用域**和**块作用域**

> 建议：当你第一次使用变量时再定义它

##### 	1.2.5嵌套的作用域

作用域中意担声明了某个名字，它所嵌套的所有作用域中都能访问该名字，同时，允许在内层作用域只用重新定义外层作用域已有的名字



#### 1.3复合类型

复合类型是指基于其他类型定义的类型，C++语言有几种符合类型，这里主要介绍两种：**引用和指针**

##### 	1.3.1引用

> C++11中新增了一种引用，所谓的“右值引用”，这种引用主要时用于内置类。严格来说，当我们使用术语“引用（reference）”时，我们说的时“左值引用”

```c++
int x = 1024;
int &rex = x;//rex指向x，（相当于是另外一个名字）
int &rex2;//报错，引用必须初始化
int &rex = 10;//错误，必须是一个对象
double dval = 1.11;
int &rex = dval;//错误，必须是相同类型
```

##### 	1.3.2指针

取地址符`&`

指针值（即地址）应属下列4种状态之一：

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针，意味着没有指向任何对象
- 无效指针，也就是上述情况之外的其他值

**空指针**

`nullptr`：C++11新特性，就是0，是一种特殊类型的字面值，它可以被转换成任意其他的指针类型

`NULL`：预处理变量，就是0，在头文件<cstdlib>中

> **建议初始化所有指针**

```c++
//三种生成空指针的方法
int *p = nullptr;
int *p2 = 0;
// 首先需要#include <cstdlib>
int *p3 = NULL;
```

**指针和赋值**

引用本身并非一个对象，它在绑定之后无法更改，但是指针可以

**void*指针**

> void* 是一种特殊的指针类型，可以存放任意对象的地址，这一点和其他指针类似，但是我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作

##### 	1.3.3理解复合类型的声明

`int* p;`

我们说这种写法可能产生误导使用为int *放在一起好像是这条语句中所有变量共同的类型一样，起始恰恰相反，基本数据类型是int，而不是int * 。 * 只是修饰了p而已，对该声明语句中的其他变量，它并不产生任何作用

```c++
// int    int*    int*
int i = 1024, *p = &i, &r = i;
// int* int
int *p1, p2;
```

> 上面两种定义指针或者引用的不同方法没有孰对孰错十分，关键是选择并坚持其中的一种方法，不要总是变来变去。
>
> 推荐使用*和&和变量名连在一起

**指向指针的指针**

多级指针

**指向指针的引用**

> 引用本身不是一个对象，因此不能定义指向引用的指针，但是指针是对象，所以存在对指针的引用

```c++
int i = 43;
int *p;   //p是一个int型的指针
int *&r = p;//r是一个对指针p的引用

r = &i; //r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0; //解引用r得到i，也就是p指向的对象，将i的值改成0
```



#### 1.4const限定符

有时候我们希望，有这样一种变量，他的值不能被改变，例如，用一个变量来表示缓冲区的大小，使用变量的好处是当我们觉得缓冲区大小不在合适时，很容易对其做出调整，另一方面，也应随时警惕防止程序一不小心改变了这个值，为了满足这个条件，我们使用const这个关键字对变量的类型加以限定：

`const int bufSiuze = 512;`

**初始化和const**

因为const对象一旦被创建之后就无法改变，所以const对象必须初始化

**默认情况下，const对象仅在文件内有效**

编辑器在编译过程中吧用到该变量的地方都替换成初始值，为了执行上述替换，编译器必须知道变量的初始值，如果程序包含多个文件，则每个都要能访问到const对象才行，要这样，就必须在每一个文件中都有对他的定义，默认情况下，const对象被设定为仅在文件内有效，当对个文件中出现了同名的const变量时，其实等于在不同文件中分别定义了独立的变量。

某时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件中共享，这种情况下，我们不希望编译器为每一个文件生成独立的变量，相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。

解决办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了， 

```c++
//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
//file_1.h头文件
extern const int bufSize; //与上面是同一个
```

**如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字**

##### 	1.4.1const的引用

可以把引用绑定在const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能作为修改他们所绑定的对象

> **术语：常量引用是对const的引用**
>
> C++程序员们经常把词组“对const的引用”简称为常量引用，这一简称还是挺不靠谱的，不过前提是你时刻记得这就是个简称而已
>
> 严格来说，并不存在常量引用，因为引用不是一个对象，所以我们设法让引用本身恒定不变，事实上，由于C++语言并不允许任意改变引用多绑定的对象，所以从这层意思上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其多能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。

**初始化和对const的引用**

允许一个常量引用绑定非常量的对象，字面值，甚至是一个表达式

const int& 一个浮点数，系统会创建一个中间变量（临时量），会绑定这个中间量，精度擦除。因为是const的，其实也不能改变。

当上面一行中不是const时，绑定了中间临时量，就不能通过引用的方式改变原值，所以当不是常量的时候，C++语言也就把这种行为归为非法，会报错！

**对const的引用可能引用一个并非const的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定，因为对象可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i;
const int &r2 = i;
r1 = 0;  //正确
r2 = 0;  //错误, r2是一个常量引用
```

r2绑定（非常量）整数i是合法的行为，然而，不允许通过r2修改i的值，尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改

##### 	1.4.2指针和const

**指向常量的指针**不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针

```c++
const double pi = 3.15;
double *ptr = &pi; //错误，ptr是一个普通指针
const double *cptr = &pi; //正确，
*cptr = 42;  //错误，不能赋值
```

> 试试这样想：所谓指向常量的指针或引用，不过是指针或引用”自以为是“罢了，他们决定自己指向了常量，所以自觉的不去改变所指对象的值

**const指针**

把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的哪个值

```c++
int x = 0;
int *const px = &x;
(*px) ++;
cout << *px << endl;

const double pi = 3.14;
const double *const pip = &pi;
// (*pip) ++;  错误
cout << *pip << endl;
```

##### 	1.4.3顶层const

> 指针本身是一个对象，它又可以指向另外一个对象，因此，指针本身不是常量以及指针所值的是不是一个常量就是两个相互独立的问题，用**名词顶层const**，和**名词底层const**表示指针所指的对象是一个常量

```c++
int i = 0; 
int *const pi = &i;//顶层
const int ci = 42;//顶层
const int *p2 = &ci;//底层
const int *const p3 = p2;// 底层    顶层
const int &r = ci;//底层
```

当执行对象的拷贝操作时，常量是顶蹭const还是底层const区别明显，其中，顶层const不受影响

执行拷贝操作不会改变拷贝对象的值，因此，烤入可烤出的对象是否是常量都没有什么影响

另一方面，底层const的限制不能缺不能忽略，当执行对象的拷贝操作时，拷入和烤出的对象不许具有相同的底层const资格，或者两个对象的数据类型能够转换，一般来说，非常量可以转换成常量，反之则不行

```c++
i = ci;//正确，拷贝ci的值，ci是一个顶层const，对此操作无影响
p2 = p3;//正确，p2和p3指向的对象类型相同，p3顶层const的部分不影响
int *p = p3;//错误，p3包含底层const的含义，而p没有
p2 = p3;//正确，p2和p3都是底层const
p2 = &i;//正确，int* 能转换成const int *
int &r = ci;// 错误，普通的int& 不能绑定到int常量上
const int &r2 = i; //错误，const int& 可以绑定到一个普通int上
```

p3即是顶层const也是底层const，拷贝p3时可以不在乎它是一个顶层const，但是必须清楚他指向的对象得是一个常量，因此，不能用p3去初始化p，因为p指向的是一个普通的（非常量）整数，另一方面，p3的值可以赋值给p2，是因为这两个指针都是底层const，尽管p3同时也是一个常量指针（顶层const），仅就这次赋值而言不会有什么影响

##### 	1.4.4constexpr和常量表达式

 **常量表达式**是指值不会改变并且在编译过程就能得到计算结果的表达式，先然，字面值属于常量表达式，用常量表达式初始化const对象也是常量表达式，后面将会提到，C++语言中有几种情况下是要用到常量表达式的

```c++
const int max_files = 20;// 是，直接得到
const int limit = max_files + 1;//是 通过常量直接得到
int staff_size = 27;//不是 不是const
const int sz = get_size();//不是 需要通过函数计算才能得到
```

**constexpr变量**

在一个复杂系统中，很难（几乎是不能）分辨一个初始值到底是不是一个常量表达式，当然可以定义一个const变量并把它的初始值设置为我们认为的某个常量表达式，但是实际使用时，尽管要求如此却常常初始化并非常量表达式的情况，可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿

C++11新标准规定，允许将变量声明为constexpr类型，以便由编译器来验证变量的值是否是一个常量表达式，声明为constexpr的变量一定是一个常量，并且必须使用常量表达式初始化：

```c++
constexpr int mf = 20;//20是常量表达式
constexpr int limit = mf + 1;//mf+1是常量表达式
constexpr int sz = size();//只有当size()是一个constexpr函数时才是一条正确的声明语句
```

尽管不能使用普通函数作为constexpr变量的初始值，但是后面（书214页）有介绍，新标准允许定义一种特殊的constexpr函数，这种函数足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。

> 一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型

**字面值类型**

常量表达式的值在编译时就得到计算， 因此对声明constexpr时用到的类型必须有所限制，因为这些类型一般比较简单，值页显而易见，就把他们称为“
字面值”

**指针和constexpr**

[constexpr的用法概述](https://www.jianshu.com/p/34a2a79ea947)

明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：

```c++
const int *p = nullptr;//p是一个指向整形常量的指针
constexpr int *q = nullptr;//q是一个指向整数的常量指针
```

p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键字在于constexpr把它所定义的对象置为了顶层const

与其他指针类似，constexpr指针既可以指向常量也可以指向一个非常量：

```c++
constexpr int *np = nullptr; //np是一个指向整数的常量指针，其值为空
int j = 0;//
constexpr int i = 42;//i的类型是整形常量
//i和j都必须定义在函数体之外
constexpr const int *p = &i;//p是常量指针，指向整形常量i
constexpr int *pl = &j;//p1是常量指针，指向整数j
```

>constexpr是C++11开始提出的关键字。
> C++11中的constexpr指定的函数返回值和参数必须要保证是字面值，而且必须有且只有一行return代码，这给函数的设计者带来了更多的限制，比如通常只能通过return 三目运算符+递归来计算返回的字面值。
> 很多人都把constexpr和const相比较。其实，const并不能代表“常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。
>
>而这个变量的值，可以在运行时也可以在编译时指定。constexpr可以用来修饰变量、函数、构造函数。
>
>一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。



#### 1.5处理类型c++

##### 	1.5.1类型别名

```c++
typedef double wages; //wages是double的同义词
typedef wages base, *p; //base是double的同义词，p是double*的同义词

//C++11定义了using方法
using SI = Sales_item; //SI 是Sales_item的同义词
```

**指针，常量和类型别名**

```c++
typedef char *pstring;
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps; //ps是一个指针，他的对象是指向char的常量指针
```

const pstring是指向char的常量指针，而不是指向常量字符的指针

比如：

const char *cstr = 0;与

const pstring cstr = 0;不一样，将其还原有时候意思就变了

##### 	1.5.2auto类型说明符

根据后面自行推断

**复合类型，常量和auto**

**auto一般会忽略掉顶层const，同时底层const会保留下来**

如果希望推断出的类型是顶层const，则需要指出

`const auto f = ci;`

设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留（加前导const）。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。

切记，&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型

##### 	1.5.3decltype类型指示符

``` cpp
decltype(f()) sun = x; //sum的类型就是函数f的返回类型
```

decltype处理顶层const和引用的方式和auto有些许不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和 引用在内）

decltype和引用

``` cpp
//decltype的结果可以时引用类型
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; //正确，加法的结果是int，所以b是一个未初始化的int
decltype(*p) c; //错误，c是int&，必须初始化
```

另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型

如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型，如果给变量加上一层或多层括号，编译器就会把他们当成是一个表达式，变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型

> 切记：decltype((var))（注意是双层括号，的结果永远是引用)，而decltype(var)结果只有当var本身就是一个引用时才是引用



#### 1.6自定义数据结构

##### 	1.6.1定义Sales——data类型

```cPP
struct Sales_data {/*    */} accun, trans, *salesptr;
//与上一条语句等价，但可能更好一些
struct Sales_data {/*    */}；
Sales_data accum, trans, *salesptr;
```

分号表示声明符（通常为空）的结束，一般来说，最好不要把对象的定义和类的定义放在一起，这么做无异于把两种不同的实体混在了一条语句里，一会儿定义**类**，一会儿又定义**变量**，显然这是一种不被建议的行为

当然可以使用typedef将其取个别名

##### 	1.6.2使用Sales_data类

正常使用

##### 	1.6.3编写自己的头文件

预处理器概述

C++程序还会用到的一项预处理功能是头文件保护符：

``` c++
#ifndef SALES_DATA_H //当且仅当变量未定义时为真 ，当为真，往下执行到#endif;结束
// #ifdef SALES_DATA_H //当且仅当变量已定义时为真
#define SALES_DATA_H //把一个名字设定为预处理变量，上面两个分别检查某个指定的预处理变量是否已经定义
#include <string>
struct Sales_data {
    int a;
};
#endif; //到这里结束
```

> 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要



### 2、字符串、向量和数组

#### 2.1命名空间的using声明

正常使用

**每个名字都需要独立的using声明：**

按照规定，每个using声明引入命名空间中的一个成员，例如：using std::cin  

**头文件不应包含using声明:**

这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件中又某个using的声明，那么每个使用了该头文件的文件就都会有这个声明，对于某些程序来讲，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突

#### 2.2标准库类型string

正常使用

> 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string对象，切记，字符串字面值与string时不同的类型

##### 	2.2.1定义和初始化string对象

正常使用

##### 	2.2.2string对象上的操作

正常使用

``` cpp
getline(cin, arr); //遇到回车停止
```

##### 	2.2.3处理string对象中的字符

在cctype头文件中定义了一组标准库函数处理这部分工作：

```cPP
isalnum(c) 当c时字母或数字时为真
isalpha(c) 当c时字母时为真
……
```

> **使用C++版本的头文件**
>
> C++标准库中除了定义C++语言特有的功能之外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++则将这些文件命名为cname。
>
> 一般来说C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到，如果使用.h形式的头文件，程序员就不得不时刻牢记哪些时从C语言哪儿继承过来的，哪些又是C++语言所特有的



#### 2.3标准库类型vector

C++语言既有类模板，也有函数模板，其中vector是一个类模板，只有对C++有了相当深入的理解才能写出模板。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明，编译器根据模板创建类或函数的过程称为**实例化**

> vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

**正常使用**



#### 2.4迭代器介绍

正常使用

**迭代器类型：**

``` cpp
vector<int>::iterator it; //it能读写vector<int>的元素
string::iterator it2;//it2能读写string的元素
vector<int>::const_iterator it3;//it3只能读元素，不能写元素
string::const_iterator it4;//it4只能读字符，不能写字符
```

**结合解引用和成员访问操作：**

箭头运算符（->）或者点运算符（.）

某些vector对象的操作会使迭代器失效

> 虽然vector对象可以动态地增长，但是也会有一些副作用，已知的一个限制是不能在范围for循环中向vector对象添加元素，另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back，会使vector对象的迭代器失效

**谨记：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素**

**迭代器运算：**

​	string 和vector的迭代器提供了更多的运算符，一方面可以使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算，所有这些运算被称为迭代器运算，上述两个对象支持下列操作

``` cpp
it + n; //移动n个位置
it - n; //移动n个位置
it += n; //移动n个位置
it -= n; //移动n个位置
it1 - it2 //得到之间的距离，分正负数，中间的元素个数，左开右闭
>、 >=、 <、 <= //参与的迭代器必须是同一个容器（同一种类型即可）中的元素，或者尾元素的下一个位置，比较地址的大小
```



#### 2.5数组

**正常使用**

不允许拷贝和赋值（初始化的时候）

没有引用数组

指针和数组……

**指针也是迭代器**



**C风格字符串：**

C++定义在cstring中，C中定义在string.h中

``` cpp
strlen(p);
strcmp(p1, p2);
strcat(p1, p2);
strcpy(p1, p2);
```



**标准库函数**

标准库函数由begin()和end()函数

``` cpp
int ia[] = {1, 2, 3, 4, 5};
int *a = begin(ia); //指向数组首部
int *b = end(ia);  //指向数组尾部的下一个位置
```



**c_str：**

如果程序的某个地方需要一个C风格的字符串，无法使用string对象来代替它，为了完成该功能，string专门定义了一个c_str的成员函数

``` c
char *str = s; //错误，不能用string对象初始化char*
const char *str = s.c_str(); //正确

//下面两个操作之后，arr.size()为0，本身scanf不能输入到arr内部，而是给了arr.c_str(),打印的时候也是c_str()
scanf("%s", arr.c_str());
printf("%s", arr.c_str());
```

**顾名思义，c_str函数的返回值是一个C风格的字符串，也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象一样，结果指针的类型是const char*， 从而确保我们不会改变字符数组的内存**

**我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用**

> 如果执行完c_str函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份



**使用数组初始化vector**

``` cpp
int arr[] = {1, 2, 3, 4, 5};
//ivec中有六个元素，分别是arr中对于元素的副本，后续修改vector,int对应的位置不该，相当于深拷贝
vector<int> ivec(begin(arr), end(arr));
```



#### 2.6多维数组

正常使用



类型别名简化多维数组的指针

``` cpp
using int_array = int[4];//新标准下类型别名的声明，
typedef int int_array[4];//等价的typedef声明

//输出ia中每个元素的值，每个内层数组各占一行， 三行四列
for(int_arrat *p = ia; p != ia + 3; ++ p){
    for(int *q = *p; q != *p + 4; ++q)
       	cout << *q << ' ';
   cout << endl;
}
```



### 3、表达式

#### 3.1基础

##### 	3.1.1基本概念

- 组合运算符和运算对象
- 运算对象转换
- 重载运算符
- 左值和右值

> 左值和右值：当一个对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置）

##### 	3.1.2优先级和结合律

- 复合表达式
- 括号无视优先级与结合律
- 优先级与结合律有何影响

##### 	3.1.3求值循序

- 求职顺序、优先级、结合率

> **建议：**
>
> 1. 拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求
> 2. 如果改变了某个运算对象的值，在表达式的其他地方不要在使用这个运算对象
>
> 第二条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效，例如在表达式*++iter中，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或此类情况下），求值的顺序不会成为问题，因为递增运算(即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算，显然，这是一种很常见的用法，不会有什么问题。



#### 3.2算术运算符号

正常使用， **统一向0取整**



#### 3.3逻辑和关系运算符

- 运算符
- &&    ||    ！
- 短路原则
- 相等性测试和布尔字面值

``` cpp
int val = 100;
if(val) {/*   */};
if(!val) {/*   */};
if(val == true) {/*   */};//编译器会把true先变成1，然后再相比较，最好使用上面两种，是将val转换成bool来判断的
if(val == 1) {/*   */};
```



#### 3.4赋值运算符

无论左侧运算对象的类型是什么，初始值列表都可以位空，此时，编译器创建一个值初始化的临时量并将其赋值给左侧运算对象

- 赋值运算满足右结合律
- 赋值运算优先级较低
- 切勿混淆相等运算符和赋值运算符
- 复合赋值运算符



#### 3.5递增和递减运算符

> **建议：除非必须，否则不用递增递减运算符的后置版本**
>
> 有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单，前置版本的递增运算避免了不必要的工作，它把值加1后直接返回了运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。
>
> 对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化，但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了，建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且重要的是写出的代码会更复合编程的初衷

运算对象可以按任意顺序求值

 

#### 3.6成员访问运算符

（.） （->） 正常使用



#### 3.7条件运算符

（？：）

- 嵌套条件运算符（随着条件运算嵌套层数的增加，代码的可读性急剧下降，因此，条件运算的嵌套最好别超过两到三层）
- 在输出表达式中使用条件运算符



#### 3.8位运算符

| 运算符 | 功能   | 用法           |
| ------ | ------ | -------------- |
| ~      | 位求反 | ~ expr         |
| <<     | 左移   | expr1 << expr2 |
| >>     | 右移   | expr1 >> expr2 |
| &      | 位与   | expr1 & expr2  |
| ^      | 位异或 | expr1^ expr2   |
| \|     | 位或   | expr1 \| expr2 |

> c++ : 
>
> ​	`^ & | ~` 会连同符号位一起操作
>
> ​	>> 是算术右移，正数高位补0，负数高位补1
>
> ​	<< 是逻辑左移，会覆盖符号位

- 移位运算符
- 位求反运算符
- 位与，位或，位异或运算符
- 使用位运算符
- 移位运算符（又叫IO运算符）满足左结合律



#### 3.9sizeof运算符

sizeof运算符返回一条表达式或一个类型名字所占的字节数，sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式

``` cpp
//两种写法
sizeof type
sizeof (type)
```

**对string对象或vector对象执行sizeof运算只返回该类型固定部分大小，不会计算对象中的元素占用了多少空间**



#### 3.10逗号运算符

用于for里面，例如`for(int i, j; i < 100; i ++, j ++)`

用于压行，来减少代码冗余



#### 3.11类型转换

##### 	3.11.1算术转换

- 整数提升
- 无符号类型的运算对象
- 理解算术转换

##### 	3.11.2其他隐式类型转换

- 数组转换成指针（数组命就是首地址，就是一个指针）
- 指针的转换
- 转换成bool类型
- 转换成常量
- 类类型定义的转换

##### 	3.11.3显示转换

- 命名的强制类型转换

#### 3.12运算符优先级表

自己查看运算符优先级表

正常使用

### 4、语句

#### 4.1简单语句

语句结尾加上一个分号就成了表达式语句，表达式语句的作用是执行表达式并丢弃掉求值结果

**空语句**

就是一个分号

**复合语句**

正常使用



#### 4.2语句作用域

花括号内部



#### 4.3条件语句

##### 4.3.1if语句

正常使用



##### 4.3.2switch语句

**swith需要注意在case里面元素的声明周期，防止在case里面定义变量**

```c++
int x; 
while(cin >> x){
	switch(x){
		case 1 : break;
		case 1 : break;
		case 1 : break;
		case 1 : break;
		
        default: break;
	}
}
```

可以多个case共同使用一个语句块，例如下面：

``` cpp
int i = 0;
switch (ch){
    case 'a' :
    case 'b' :
    case 'i' :
    case 'o' :
    case 'u' :
        ++ i; break;
        
    default: break;
}
```



#### 4.4迭代语句

##### 4.4.1while语句

正常使用



##### 4.4.2for语句

`for(initializer; condition; expression)`

> break 和continue会跳到第三个位置，执行第三项完毕之后再开始新的循环



##### 4.4.3范围for语句

`for(declaration : expression)`

**合理运用auto**



##### 4.4.4do while语句

``` cpp
do{
    
}while();
```



#### 4.5跳转语句

##### 4.5.1break;

跳出离他最近的while、do while、for或 switch语句



##### 4.5.2continue语句

终止最近的循环中的当前迭代器并立即开始下一次迭代

**只有在switch语句嵌套在迭代语句内部时，才能在switch里使用continue**



##### 4.5.3goto语句

紧记，使用类似goto的语句，要充分考虑程序的合理性，中间是否有变量的定义声明等等

``` cpp
goto end;


end:
```



#### 4.6try语句块和异常处理

> 异常处理机制为程序中异常检测和异常处理着两部分的协作提供支持，在C++语言中，异常处理包括：
>
> - throw表达式：异常检测部分使用throw表达式来表示它遇到了无法处理的问题，我们说throw引发（raise）了异常
> - try语句块：异常处理部分使用了try语句块处理异常，try语句块以关键字try开始，并以一个或多个catch子句结束，try语句块中代码抛出的异常通常会被某个catch子句处理，因为catch子句“处理”异常，所以他们也被称作**异常处理代码**
> - 一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息

##### 4.6.1throw表达式

程序的异常检测部分使用throw标傲世引发的一个异常，throw表达式包含关键字和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型，throw表达式后面通常紧跟一个分号，从而构成一条表达式语句，例如：

一般情况：

``` cpp
int a, b; 
cin >> a >> b;
if(a != b){
    cout << a + b << endl;
    return 0; //表示成功
}else{
    cerr << "Data must refer to same ISBN" << endl;
    return -1; //表示失败
}
```

在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来，此例中，我们改写程序使得检查完成后不再直接输出一条信息，而是抛出一个异常：

``` cpp
if(a != b)
    throw runtime_error("Data must refer to same ISBN");

//如果程序执行到了这里，表示两个数是相同的
cout << a + b << endl;

/*
程序运行实际例
1 2
terminate called after throwing an instance of 'std::runtime_error'
  what():  Data must refer to same ISBN
*/
```



##### 4.6.2try语句块

通用语法形式是：

``` cpp
try{
    program-statements
}catch (exception-declaration){
    program-statements
}catch (exception-declaration){
    program-statements
} //……
```

try语句块的一开始是关键字try，随后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列

跟在try后面的是一个或者多个catch子句，catch包含三部分，关键字catch，括号内一个（可能未命名的）对象的声明（称作异常声明）以及一个块。当选中了一个catch子句处理异常之后，执行与之对应的块，catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行

try语句块中的program-statements组成程序的正常逻辑，就像其他任何块一样，program-statements可以有包含声明在内的任意C++语句，一如既往，try语句块内声明的变量在块外部无法访问，特别是在catch子句也无法访问

**编写处理代码**

``` cpp
while(cin >> a >> b){
    try{
     	//执行balabala   
        //如果异常，代码抛出一个runtime_error异常
    }catch (runtime_error err){
        cout << err.what() << "\nTry Again Enter y or n" << endl;
        char c;
        cin >> c;
        if(!cin || c == 'n') //下面有介绍
            break;//跳出while循环
    }
}
```

> 关于！cin
>
>        1、每一个输入（输出）对象就代表一个输入（输出）流
>         
>        2、输入（输出）对象中的流状态成员标记了输入（输出）流当前的状况，当eofbit、badbit、failbit三个标记位均为0时表示流状态正常
>         
>        3、一但某个或几个标记位被设置，表示对象的流状态出现相应状况，流将对后面的输入（输出）关闭，直到标记位被清除
>         
>        4、只有在流状态良好的情况下，if或者while对该输入（输出）对象的判断才能是Ture



给用户的提示信息是err.what()的返回值，err的类型是runtime_error，因此能推断出what是runtime_error的一个成员函数，每个标准库异常类都定义了一个名为what的成员函数，这些函数没有参数，返回值是C风格的字符串，其中runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本，如果上一节编写的代码抛出异常，则本节的catch子句输出

```c++
Data must refer to same ISBN
Try Again Enter y or n
```



**函数在寻找处理代码的过程中退出**

> ​	在复杂系统中，程序在遇到抛出异常的代码前, 其执行路径可能已经经过了多个try 语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。
> ​	寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的 catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。
> ​	如果最终还是没能找到任何匹配的catch子句，程序转到名为 **terminate** 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。
> ​	对于那些没有任何try语句块定义的异常，也按照类似的方式处理: 毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。	



##### 4.6.3标准异常

C++标准库定义了一组类，用于报告标准库函数遇到的问题，这些 异常类也可以在 用户编写的程序中使用，分别在下面四个头文件中：

- exception 头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息
- stdexcept 头文件定义了几种常见的异常类，见表格
- new 头文件定义了bad_alloc异常类型
- type_info 头文件定义了bad_cast异常类型



| ＜stdexcept＞定义的异常类 | 解释                                           |
| ------------------------- | ---------------------------------------------- |
| exception                 | 最常见的问题                                   |
| runtime_error             | 只有在运行时才能检测出的问题                   |
| range_error               | 运行时错误：生成的结果超出了有意义的值域范围   |
| overflow_error            | 运行时错误：计算上溢                           |
| underflow_error           | 运行时错误：计算下溢                           |
| logic_error               | 程序逻辑错误                                   |
| domain_error              | 逻辑错误：参数对应的结果值不存在               |
| invalid_argument          | 逻辑错误：无效参数                             |
| length_error              | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
| out_of_range              | 逻辑错误：使用一个超出有效范围的值             |



### 5、函数

#### 5.1函数基础

一个典型的函数定义包括以下部分：**返回类型**，**函数名字**，**由0个或多个形参组成的列表以及函数体**

正常使用



##### 5.1.1局部对象

**自动对象**：我们把子存在于块执行期间的对象称为自动对象

**静态局部变量**：在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响

`static int x = 10;`



##### 5.1.2函数声明

函数的三要素：（返回类型，函数名，参数类型）。描述了函数的接口，说明了调用该函数所需的全部信息，函数声明也称为函数原型

**在头文件中进行函数声明**

正常使用



##### 5.1.3分离式编译

**编译和链接多个源文件**

如果外面修改了其中一个源文件，那么只需要重新编译哪个改动了的文件，大多数编译器提供分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（Windows）或.o（UNIX）的文件，后缀名的含义是该文件包含对象代码

正常使用



#### 5.2参数传递

引用传递（传引用调用），值传递（传值调用）

##### 5.2.1传值参数

- 指针形参



##### 5.2.2传引用参数

- 使用引用避免拷贝
- 使用引用形参避免返回额外信息



##### 5.2.3const形参和实参

> 和其他初始化过程一样，当调用实参初始化形参时会忽略顶层const，换句话说，形参的顶层const被忽略了，当形参有顶层const时，传给它常量对象或者非常量对象都是可以的，意思就是const int 作为实参，int作为形参，最后还是没有const，只有形参自己时const的时候才有顶层const

``` cpp
void fun(const int i) //能读取i，但是不能写i
void fun(int i)//
```

**指针或引用形参与const**

形参的初始化方式和变量的初始化方式是一样的

正常使用

**尽量使用常量引用**

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做会给函数的调用者一种误导，即函数可以修改它的实参的值，此外使用引用而非常量引用也会极大地限制含糊所能接受的实参类型，就像刚刚看到的，**我们不能把const对象，字面值或者需要类型转换的对象传递给普通的引用形参**（一般来讲记不住，需要用的时候上手试一下就可以了）



##### 5.2.4数组形参

数组的两个特殊性质对我们定义和使用所用在数组上的函数有影响，这两个性质分别时：不允许拷贝数组，以及使用数组时（通常）会将其转换成指针。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数，因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针

虽然不能以值传递方式传递数组，但是我们可以把形参写成类似数组的形式：

``` cpp
void pirnt(const int*);
void print(const int[]);//可以看出来，函数的意图是作用以一个数组
void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定
```

尽管形式不一样，但是上面三个函数是等价的，每个函数的唯一参数都是const int*类型的，当编译器处理对print函数的调用时，只检查传入的参数是否时const int * 的

因为数组十一指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息，管理指针形参有三种常见的技术。

- 使用标记指定数组长度（利用数组本身包含一个结束符，所以可以求一遍）
- 显示传递一个表示数组大小的形参（多给一个参数，告知数组有多长）
- 使用标准库规范（begin(arr), end(arr)）给头指针和尾指针的下一个位置

**数组形参和const**

我们的单个print函数都把数组形参定义成了指向const的指针，关于引用的讨论同样适用于指针，当函数不需要对数组元素执行写操作的时候，数组形参应该指向const的指针，只有当函数确实要改变元素值的时候，才把形参定义称为指向非常量的指针



**数组引用形参**

C++语言运行将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用，此时引用形参绑定到对应的形参上，也就是绑定到数组上：

``` cpp
// &arr两端的括号必不可少
f(int &arr[10]); //错误，将arr声明成了引用的数组
f(int (&arr)[10]); //正确，arr是具有是个整数的整形数组的引用
```



**传递多维数组**

``` cpp
//再一次强调，*matrix两端的括号必不可少
int *matrix[10]; //10个指针构成的数组
int (*matrix)[10]; //指向含有10个整数的数组的指针

void print(int (*matrix)[10], int rowSize);
//等价于
void pirnt(int matrix[][10], int rowSize); //声明看起来像一个二维数组，实际是指向含有10个整数的数组的指针
//指针是指向含有10个整数的数组，就是二维数组的第一行，将这个指针++，就指向二维数组的第二行
```



##### 5.2.5 main：处理命令行选项

``` cpp
main(int argc, char *argv[]){
    
}

//假设main函数位于可执行文件prog之内，假设命令行命令如下
prog -d -o ofile data0
//则argv = 5，表示argv数组中字符串的数量，argv则存储上面的每一个字符串，自己的名字始终是argv[0],其它的从argv[1]开始
```

> 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入



##### 5.2.6含有可变形参的函数

有时候我们无法预知应该向函数传递几个实参，所以我们有两种解决方案。

一是当所有参数的类型相同时，可以使用initializer_list的标准库类型

二是我们可以编写一种特殊的函数，也就是所谓的可变参数模板，在后面会讲解到



**initializer_list形参**

initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，initializer_list类型定义在同名的头文件中，它提供以下操作：

| 写法                              | 用法                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| initializer_list<T> lst           | 默认初始化；T类型空间的空列表                                |
| initializer_list<T> lst{a, b, c}; | lst的元素和初始值一样多，lst的元素时对应初始值的副本，列表中的元素时const的 |
| lst2（lst）                       | 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素 |
| lst2 = lst                        | 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素 |
| lst.size()                        | 列表中的元素个数                                             |
| lst.begin()                       | 返回指向lst中首元素的指针                                    |
| lst.end()                         | 返回指向lst中尾元素下一最值的指针                            |

基本上和vector用法一样， 和vector不一样的是，initializer_list对象中的元素永远都是常量值，我们无法改变initializer_list中元素的值

``` cpp
//ecprcted和actual是string对象
if(ecprcted != actual)
    error_msg({"functionX", expected, actual});
else
    error_msg({"functionX", "okay"});
```

上面的代码中调用了同一个函数error_msg，但是两个传递的参数数量不一样.

含有initializer_list形参的函数也可以同时拥有其他形参，例如调试系统可能有个名为ErrCode的类用来表示不同类型的错误，因此我们可以改写之前的程序，使其包含一个initializer_list形参和一个ErrCode形参

```c++
void error_msg(ErrCode e, initializer_list<string> il){
    cout << e.mag() << ": ";
    for(const auto &elem : il)
        cout << elem << " ";
   	cout << endl;
}
```

**省略符形参**

> **省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能，通常，省略符形参不应用于其他目的，你的C编译器文档会描述如何使用varargs**
>
> 省略符形参应该仅仅用于C和C++通用的类型，特别应该注意的是，大多是类类型的对象在传递给省略符形参是都无法正确拷贝
>
> 省略符形参只能出现在形参列表的最后一个位置，无外乎以下两种形式
>
> ``` cpp
> void foo(parm_list, ...);
> void foo(...);
> ```
>
> 第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正确的类型检查，省略符形参所对应的实参无需类型检查，**在第一种形式中，形参声明后面的逗号是可选的**



#### 5.3返回类型和return语句

##### 5.3.1无返回值类型

正常使用

##### 5.3.2有返回值类型

> 在含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的，很多编译器都无法发现这类错误

- 值是如果被返回的：临时量
- 不要返回局部对象的引用或指针
- 返回类型的函数和调用运算符
- 引用返回左值
- 列表初始化返回值：或括号，在error_msg中也用到
- 主函数main的返回值：编译器将隐式地插入一条0的return语句（非0值可能与机器有关，所以可以使用cstdlib头文件下的（EXIT_FAILURE 和 EXIT_SUCCESS））
- 递归：正常使用，main函数不能递归调用自己



##### 5.3.3返回数组指针

声明一个返回数组指针的函数

``` cpp
int arr[10]; //arr是一个含有是个整数的数组
int *p1[10]; //p1是一个含有是个指针的数组
int (*p2)][10]; //p2是一个指针，它指向含有10个整数的数组
```

举个例子，下面这种返回类型：

`int (*func(int i))[10];`

这样来理解：

- func(int i)表示调用func函数时需要一个int类型的实参
- (*func(int i)） 意味着我们可以对函数调用的结果执行解引用操作
- (*func(int i))[10]意味着解引用func的调用将得到一个大小是10的数组
- int (*func(int i))[10]表示数组中的元素时int类型的

类型模板：

`Type (*function(parameter_list))[dimension]`

和前面的  int (*arr)[10]是一个道理，意思是func返回的类型和arr是一样的类型，func和arr的位置都一样，说明两个的类型是一样 ，按照上面四部拆开来看也可以说得通



**使用尾置返回类型**

任何函数的定义都能使用使用尾置返回类型，但是这种形式对应返回类型比较复杂的函数最有效，比如返回类型是数组的指针胡总和数组的引用，使用尾置返回类型跟在形参列表后面并以一个->符号开头，为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置了一个auto

``` cpp
//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int(*)[10];
```



**使用decltpye**

还有一种情况，如果我们直到韩式返回的指针指向哪个数组，那就可以使用decltpye关键字声明返回值类型，例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个

```cpp
int odd[] = {1,2,3,4};
int even[] = {2,3,4,5};

decltpye(odd) *arrptr(int i){
    return (i % 2) ? &odd : &even;//返回一个指向数组的指针
}
```

arrptr使用关键字decltpye表示它的返回值类型是个指针，并且该指针所指的对象与odd类型一致，因为odd是一个数组，所以arrptr返回一个指向含有5个整数的数组的指针，有一个地方需要注意，decltpye并不负责把数组类型转换成对应的指针，所以decltpye的结果是一个数组，想要表示arrptr返回指针还必须在函数声明时加一个*符号。

odd时数组的首地址，同时又是函数名，但是如果没有将其转换成*，那他就是一个函数名，不能是指针，所以需要添加一个 *，在后面的return中，add也是一个道理，需要返回数组的指针，虽然odd本身就是数组的首指针，但是还是需要一个取地址符&。关于更严谨的讨论在后面会有，这里先暂时了解一下，见招拆招。  



#### 5.4函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载。main函数不能重载

**定义重载函数**

正常使用

**判断两个形参的类型是否相异**

有时候两个形参列表看起来不一样，但实际上还是相同的

```cpp
//每对声明的时同一个函数
Record lookup(const Accout &acct);
Record lookup(const Accout &);  //省略了名字

typedef Phone Telno;
Record lookup(const Phone &);
Record lookup(const Telno &); //Telno和Phone的类型相同
```

**重载和const形参**

顶层const不影响传入函数的对象，一个拥有顶层const的对象无法和另一个没有顶层const的形参区分开来：

```cpp 
Record lookup(Phone);
Record lookup(const Phone); //重复声明了Record lookup(Phone);
Record lookup(Phone*);
Record lookup(Phone* const); //重复声明了Record lookup(Phone*);   //Phone是一中类型，这是顶层const
	
```

另一方面，如果形参时某种类型的指针或引用，则通过区分其指向的时常量对象还是非常量对象可以实现函数重载，此时const是底层的：

在上面的例子中，斌一起可以通过实参是否是常量来推断应该调用哪个函数，因为const不能转换成其他类型，所以我们只能把const对象传递给const形参。
**当我们传递一个非常量对象或者指向非常量对象的指针时，比那一起会优先使用非常量版本的函数**

**const_cast和重载：**
``` cpp
const string &f(const string &s1, const string &s2){
	return s1.size() <= s2.size() ? s1 : s2;
}
								
```

这个函数的参数和返回类型都是const string的引用，我们需要一种新的函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以实现：
								
```cpp
string &f(string &s1, string &s2){
	auto &r = f(const_cast<const string&>(s1), const_cast<const string&>(s2));
	return const_cast<string&>(r);
}

```
**第二个函数使用了第一个函数**

**调用了重载的函数**
调用重载有三种可能的结果：
* 编译器找到一个与实参最佳匹配的函数，并生成该函数的代码
* 找不到，无匹配
* 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时也将发生错误，成为**二义性调用**

##### 5.4.1 重载与作用域
如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。
在C++语言中，名字查找发生在类型检查之前

#### 5.5特殊用途语言特性
##### 5.5.1默认实参
正常使用
一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值

**使用默认实参调用函数**
正常使用

**默认实参声明**
正常使用

**默认实参初始值**
正常使用

##### 5.5.2内联函数和constexpr函数
**内联函数可以避免函数调用的开销**
内联函数会“内联的展开”
> 内联说明知识像编译器发出一个请求，编译器可以选择忽略这个请求

**constexpr函数**
函数的返回类型以及所有形参都得是**字面值类型**，
为了能在编译过程中随时展开，constexpr函数被隐式的指定为内联函数，constexpr函数体也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如，constexpr函数中可以有空语句，类型别名，以及using声明

> 我们允许constexpr函数的返回值并非一个常量（可以是常量表达式）
> constexpr函数不一定返回常量表达式（可以返回空）

**把内联函数和constexpr函数放在头文件内**
和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义，毕竟，编译器想要展开函数仅有函数声明是不够的，还需要函数的定义，不过，对于某个给定的内联函数或者constexpr函数来说，**他的多个定义必须完全一致**，基于这个原因，内联函数和constexpr函数通常在头文件中定义

##### 5.5.3调试帮助
**assert预处理宏**
assert是一种预处理宏，其实就是一个变量，行为类似于内联函数，assert使用一个表达式作为它的条件：
`assert(expr)`
首先对expr求值，如果表达式为假，assert输出信息并终止程序的执行，反之什么都不做
assert宏常用于检查“不能发生”的条件，例如，一个输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值，此时，程序可以包含一条如下的语句：
`assert(word.size() > threshold)`

**NDEBUG预处理变量**
assert的行为依赖于一个名为NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert什么都不做，默认状态下没有定义NDEBUG，从而关闭assert将执行运行时检查。我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态，同时很多编译器都提供一个命令行选项使我们可以定义预处理变量
详细使用见primer

#### 5.6函数匹配
**确定候选函数和可行函数**
函数匹配的第一步时选定本次调用对应的重载函数集，集合中的函数成为候选函数，候选函数具备两个特征，一是与被调用的函数同名，二是其声明在调用点可见，
第二步考察本次调用提供的实参，然后从候选参数中选出能被这组实参调用的函数，这些新选出的函数成为**可行函数**
可行函数也有两个特征，一是其形参数量与本次调用提供的实参数量相等，二十每个实参的类型与对应的参数类型相同，或者能转换成形参的类型

**寻找最佳匹配（如果有的话）**
正常使用（最接近的）

**含有多个形参的函数匹配**
如果有且仅有一个函数满足一下条件，则匹配成功：
* 该函数每个实参的匹配都不劣与其他可行函数需要的匹配
* 至少有一个实参的匹配优于其他可行函数提供的匹配

> 调用重载函数时应该尽量避免强制转换类型，如果在实际用用中确实需要强制转换类型，则说明我们设计的形参集合不合理
##### 5.6.1实参类型转换
* 精确匹配
* * 实参类型和形参类型相同
* * 实参从数组类型或函数类型转换成对应的指针类型
* * 向实参添加顶层const或者从实参中删除const
* 通过const转换实现的匹配
* 通过类型提升实现的匹配
* 通过算术类型转换
* 通过类类型转换实现的匹配

**提升有先后顺序优先级别， 类型转换没有优先级表，等级都是一样的，容易出现二义性**

**函数匹配和const实参**
正常的const属性来判断

#### 6.6函数指针
函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定，与函数名无关

`bool (*pf)(const string &, const string &);`
> *pf两端的括号必不可少，如果不写括号，则pf时一个返回值为bool指针的函数
> ```cpp
> //声明一个名为pf的函数，返回值是bool *
> ```

**使用函数指针**
见primer，具体用法和普通变量指针用法相似


**重载函数的指针**
```cpp
void ff(int **);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff;//正确

void (*pf2)(int) = ff;//错误，没有任何一个ff与该形参列表匹配
double (*pf3)(int*) = ff;//错误，ff和pf3的返回类型不匹配
```

**函数指针形参**
正常使用，函数指针作为函数的参数，和变量类似

**decltype不会将函数类型自动转换成指针，所以需要自己转换成为指针类型**

**返回指向函数的指针**
我们必须把返回类型写成指针形式，不然编译器不会自动的将函数返回类型当成对应的指针类型处理
`int (*f1(int))(int*, int);`

> 按照由内而外的顺序阅读这条语句声明，我们看到f1有形参列表，所以f1是个函数，f1前面有*，所以f1返回一个指针，进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int，
> 处于完整性考虑，我们下面写一下**尾置返回类型**
> `auto f1(int) -> int(*)(int*, int);`

**将auto和decltype用于函数指针类型**
```cpp
string::size_type sumLength(const string&, const string&);
string::size_type LargerLength(const string&, const string&);
//根据其形参的取值，getFcn函数返回指向sumLength或者LargerLength的指针
decltype(sumLength) *getFcn(const string &);
```

声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型，所以我们必须显式的加上*表明我们需要返回指针，而非函数本身


### 6、类
类的基本思想是**数据抽象**和**封装**。数据抽象是一种依赖于**接口**和**实现**分离的编程技术
#### 6.1定义抽象数据结构
正常使用

##### 6.1.1定义一个类
正常使用

##### 6.1.2定义一个改进的类
正常使用

**引入ocnst成员函数**
默认情况下，this的类型是指向类类型非常量版本的指针。
C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时紧跟在参数列表后面不的const表示this是一个指向常量的指针，像这样使用const的成员函数称为**常量成员函数**

**类作用域和成员函数**
编译器分两步处理类，首先编译成员的声明，然后才轮到成员函数体（如果有的话），因此，成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序

**在类外部定义成员函数**
正常使用

**定义一个返回this对象的函数**
我们无需使用隐式的this指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问，
`return *this*` 返回调用该函数的对象
其中return语句解引用this指针以获得执行该函数的对象，换句话说，上面这个调用返回total的引用

##### 6.1.3定义类相关的非成员函数
定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类种，则它一般应与类声明在同一个头文件，在这种方式下，用户使用接口的任何部分都只需要引入一个文件
> 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件中

**定义read和print函数**
```cpp
istream &read(istream &is, Sales_data &item){
	double price = 0;
	is >> item.boolNo >> item.units_sold;
	return is;
}
ostream &print(ostream &os, const Sales_data &item){
	os << item.isbn() << " " << item.unitd_sold << " " << item.revenue << " " << item.avg_price();
	return os;
}
```
除此之外，关于上面的函数还有两点是非常重要的，第一点，read和print分别接受一个格子IO类型的引用作为其参数，这是因为IO类型属于不能被拷贝的类型，因此我们只能通过引用来传递它们，而且，因为读取和写入的操作会改变流的类容，所以两个函数接受的都是普通引用，而非对常量的引用
第二点，print函数不负责换行，一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行

**定义add函数**
```cpp
Sales_data add(const Sales_data &lhs, const Sales_data &rhs){
	Sales_data sum = lhs; //把lhs的数据成员拷贝给sum
	sum.combine(rhs); // 把rhs的数据成员加到sum当中
	retun  sum; 
}
```
最后函数返回sum的副本

##### 6.1.4构造函数
**合成的默认构造函数**
类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数
编译器创建的构造函数又被称为**合成的默认构造函数**，对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员
* 如果存在类内的初始值，用它来初始化成员
* 否则，默认初始化该成员

**某些类不能依赖合成的默认构造函数**
> 只有当类没有声明任何构造函数时，编译器才会自动的生成默认构造函数
> 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全部都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数

**default的含义**
在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 = default
```cpp
Sales_data() = default;
```

**构造函数初始值列表**
接下来介绍类中定义的另外两个构造函数
```cpp
Sales_data(const std::string &s):boolNo(s) {}
Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n) {}
```
这两个定义中出现的新的部分，即冒号以及冒号和花括号之间的代码，其中花括号定义了（空的）函数体，我们把新出现的部分称为构造函数初始值列表，它负责为新创建的对象的一个或者几个数据成员赋初值，构造函数初始值时成员名字的一个列表，每个名字后面紧根括号括起来的（或者在花括号内的）成员初始值，不同成员的初始化通过逗号分隔开，
```cpp
//与上面定义的哪个构造函数效果相同
Sales_data(const std::string &s) : bookNo(s), units_sold(0), revenue(0){}
```
> 构造函数不应该轻易覆盖掉类内的初始值，除非新赋值的值与原值不同，如果你不能使用类内初始化值，则所有构造函数都应该显式的初始化每个内置类型的成员

**在类的外部定义构造函数**
```cpp
Sales_data::Sales_data(std::istream &is){
	read(is, *this); //read函数的作用时从is中读取一条交易信息然后存入this对象中
}
```

##### 6.1.5拷贝，赋值和析构
**某些类不能依赖于合成的版本**
关于内存问题可能需要手动析构函数

#### 6.2访问控制于封装
在C++语言中，我们使用访问说明符加强类的封装性：
* 定义在public说明符之后的成员在整个程序内可被访问到，public成员定义类的接口
* 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节

**使用class和struct关键字**
> 使用class和struct定义类唯一的区别就是默认的访问权限

#### 6.2.1友元
类可以允许其他类或者函数访问它的非共有成员，方法时令其他类或者函数成为它的友元（friend）如果类想把一个函数作为它的友元，只需要增假一条friend关键字开始的函数声明语句即可
```cpp
class Sales_data{
	friend Sales_data add(const Sales_data&, const Sales_data&);
	friend std::istream &read(std::istream&, Sales_data&);
	friend std::ostream &print(std::ostream&, const Sales_data&);

	//其他成员及访问说明符与之一致
pubilc:
	Sales_data() = default;
	Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n){ }
	Sales_data(const std::string &s) : bookNo(s) { }
	Sales_data(std::istream&);
	std::string isbn() const { return bookNo;}
	Sales_data &combine(const Sales_data&);
private:
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
//Sales_data接口的非成员组成部分的声明
Sales_data add(const Sales_data&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
std::ostrean &print(std::ostream&, const Sales_data&);
```
> 友元声明只能出现在类的定义里面，但是在类内部出现的具体位置不限，友元不是类的成员也不受它所在取余访问控制级别的约束
> 一般来说，最好在类定义开始或结束前的位置集中声明友元


## Ⅱ0：C++标准库

## Ⅲ：类设计者的工具

## Ⅳ：高级主题